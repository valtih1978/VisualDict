<!--TODO: 
1. show/hide on hover. The must be a hover option to 
make object visible/hidden. Hidden objects disappear when we 
recede the mouse too far away.
2. List of words for search.


-->
<body onLoad='startRealtime()'>
  <script type="text/javascript" src="https://apis.google.com/js/api.js"></script>
  <script type="text/javascript" src="realtime-client-utils.js"></script>
  <script type="text/javascript" src="controller.js"></script>

  <script src="libs/vis.js"></script>
  <!--
  <script src="http://almende.github.io/vis/dist/vis.js"></script>
  -->
<div id="network_div" style=""></div>

<ul id="word_list" class="controls" style="float: left; width:50; height: 100; font-size: xx-small"></ul>

  <a href="http://almende.github.io/vis/examples/network/21_data_manipulation.html">Almende</a>
  <table onmouseenter="pickButton.style.display = 'block'" onmouseleave="pickButton.style.display = 'none'" style="float: right">
	  <tr><td><button id="authorizeButton" disabled>You must authorize</button></td></tr>
	  <tr><td><button id="pickButton" onclick="pick()" style="display:none">Pick another file</button></td></tr>
  </table>
  <!-- Undo and redo buttons. -->
  <table onmouseenter="redoButton.style.display = 'block'" onmouseleave="redoButton.style.display = 'none'" style="float: right">
	<tr><td><button id="undoButton" disabled>Undo</button></td></tr>
	<tr><td><button id="redoButton" style="display:none" disabled>Redo</button></td></tr>
  </table >
  
  <table onmouseenter="classVisible('connbar', 'block')" onmouseleave="classVisible('connbar', 'none')" style="float: right">
	<tr><td><button id="connect_button" onclick="connButtonClicked([])" disabled>conn strong</button></td></tr>
	<tr><td><button class="connbar" id="circle_button" onclick="circleButtonClicked([])" disabled>circle conn</button></td></tr>
	<tr><td><button class="connbar" id="merge_button" onclick="mergeButtonClicked()" disabled title="Merge into the first selected item." style="display:none">merge</button></td></tr>
	<tr><td><button class="connbar" id="breakNodes_button" onclick="breakNodesClicked()" disabled title="Breaks connections between selected nodes">break</button></td></tr>
	<tr><td><button class="connbar" id="delete_button" onclick="deleteButtonClicked()" disabled>Delete Selected</button></td></tr>
	<tr><td><button class="connbar" id="flip_button" onclick="flipButtonClicked()" disabled>Flip Selected</button></td></tr>
  </table>
  <style>.connbar{display:none}</style>
  <table onmouseenter="classVisible('addbar', 'block')" onmouseleave="classVisible('addbar', 'none')" style="float: right">
	<tr><td><input id="input1" onkeydown="if (event.keyCode == 13) addnodeButtonClicked()"/></td></tr>
	<tr><td><button class="addbar" id="add_button" onclick="addnodeButtonClicked()" style="display:none">add node</button></td></tr>
	<tr><td><button class="addbar" id="rename_button" onclick="renameButtonClicked()" disabled style="display:none">Rename</button></td></tr>
  </table>

	<script>
		function classVisible(cls, visibility) {
			var controls = document.querySelectorAll("." + cls);
			for (var k=0 ; k < controls.length; k++)
				controls[k].style.display = visibility

		}
		
		word_list.addEventListener("click", function(e) {
			if(e.target && e.target.nodeName == "LI") {
				//console.log(e.target.textContent + " was clicked");
				selectNode(e.target.textContent)
				network.focusOnNode(e.target.textContent, {
					scale: 1, offset: {x:0,y:0},
						animation: {
							duration: 2500,
							easingFunction: 'easeInOutQuad'
						}
				})
				window.scrollTo(0,0) // browser jump. Useful for long lists
			}
		});
		function selectNode(id) {
			var selected = (shiftPressed) 
				? network.getSelection().nodes : []
			selected.push(id)
			network.selectNodes(selected) // select in graph
			onselect(network.getSelection())
		}
		function getLI(word) {
			var list = word_list.querySelectorAll('li');
			for (var k in list)
				if (list[k].textContent == word) 
					return list[k]
		}
		
		/* 
		// highlight selected words in list
		var listSelected = []
		function updateListSelection(justSelected) {
			for (var k in listSelected) {
				listSelected[k].style['font-size'] = "xx-small"
				listSelected[k].style['font-weight'] = "normal"
			}
			listSelected = []
			
			for (k in justSelected) {
				var li = getLI(justSelected[k]) 
				li.style['font-size'] = "large"
				li.style['font-weight'] = "bold"
				listSelected.push(li)
			}
		}*/
		function insertFirst(li) {
			if (word_list.firstChild) word_list.insertBefore(li, word_list.firstChild);
			else word_list.appendChild(li);
		}
		function updateListSelection(justSelected) {
			for (k in justSelected) {
				var li = getLI(justSelected[k])
				word_list.removeChild(li)
				insertFirst(li)
			}
		}

	</script>
  
  
  <span id="ConnectMode_span" style="display:none">connect mode</span>
	<style type="text/css">
	body {font-family:verdana}
	.network-manipulationLabel {display: none}
	a, span, table, button, input, .controls { position: relative; left: 0; top: 0; margin: 0; padding: 0;}
	#network_div { position: absolute; left: 0; top: 0; margin: 0;
		padding: 0; width: 100%; height: 100%; }
	</style>


<script>

	var errorsOccured = false
	window.onerror = function(errorMsg, url, lineNumber, colNo, e) {
		if (!errorsOccured)
			alert("Error " + errorMsg + " in " + url + ", line " + lineNumber + ". Watch the developer console.");
		errorsOccured = true
	};
	
	var shiftPressed = undefined ; 
	
	["keydown", "keyup"].map(function(evt) {
		window.addEventListener(evt, function(event) {
			// Bind to both command (for Mac) and control (for Win/Linux)
			shiftPressed = event.shiftKey
			if (event.keyCode == 17) {
				var down = event.type == 'keydown'
				var newDisplay = down ? 'block' : 'none'
				if (ConnectMode_span.style.display != newDisplay) {

					ConnectMode_span.style.display = newDisplay
					
					if ((network.getSelection().edges.length == 1)) {
						console.log('edit mode ' + network.getSelection().edges[0])
						//edit edge mode
						if (down) {
							ConnectMode_span.editorData = null
							network._createEditEdgeToolbar.call(network)
						}
						else {
							network._createManipulatorBar.call(network)
							recoverEditEdge()
							var newEdge = ConnectMode_span.editorData
							if (newEdge != null) {
								controller.compound(function() {
									controller.removeEdge(newEdge.id)
									controller.connect(newEdge.from, newEdge.to)
								})
							}
						}


					} else {
						// new connection mode
						console.log('new conn mode')
						network[down ? '_createAddEdgeToolbar' : '_createManipulatorBar']
							.call(network)
						/*if (network.manipulationDOM[element])
							network.manipulationDOM[element].onclick()
						else
							console.log('element ' + element + " undefined")*/
					}

				}
				
			} else if (ConnectMode_span.style.display != 'none') {
				//console.log('another key pressed!') // need to stop conn mode immediately (it has side effects)
				network._createManipulatorBar.call(network)
				ConnectMode_span.style.display = 'none'
			}
		}, true);
	})
	

	var options = {
		dataManipulation: {enabled: true, initiallyVisible:false},
		onConnect: function (edge, callback) {
			console.log('on connect ' + JSON.stringify(edge))
			controller.connect(edge.from, edge.to)
			callback([]); // cancel update. Do it with model update
		},
		onEditEdge: function (edge, callback) {
			callback(ConnectMode_span.editorData = edge); // track changes
		},
		/*nodes: { // having only text obfuscates its location on the edges
			shape: "text",
			color: {
				border: 'orange',
				background: 'white',
			}
		}*/
	};

	function control(func) {
		controller[func](input1.value)
	}
	
	function deleteButtonClicked() {
		// fired when user (rather than graph) initiates removal
		// Do the same as when graph initiates removal
		options.onDelete(network.getSelection() , function() {})
	}
	
	//fired when graph (rather than user) initiates removal. 
	// Promote the command to the model. Actualy graph will be
	// pruned on model update event.
	options.onDelete = function(deleted, cb) {
		controller.compound(function() {
			for (var key in deleted.edges) {
				console.log('deleting ' + deleted.edges[key])
				controller.removeEdge(deleted.edges[key])
			}
			for (var key in deleted.nodes) {
				console.log('deleting ' + deleted.nodes[key])
				controller.deleteNode(deleted.nodes[key])
			}
			return cb([]) // cancel delete -- do in on model update
		})
	}

	// create an array with nodes
	nodes = new vis.DataSet();
	edges = new vis.DataSet();

	function onselect(selected) {
		var nodes = selected.nodes
		console.log("selected.nodes: " + nodes.join(',') + ", network.sel.nodes: " + network.getSelection().nodes.join(','))
		delete_button.disabled = nodes.length + selected.edges.length == 0
		connect_button.disabled = circle_button.disabled =
			merge_button.disabled = (nodes.length < 2)
		breakNodes_button.disabled = (nodes.length < 2)

		rename_button.disabled = nodes.length != 1
		flip_button.disabled = (nodes.length != 2)
		
		// select item in the list
		updateListSelection(nodes)
	}
	
	function renameButtonClicked() {
		var selected = network.getSelection().nodes
		//nodes.update({id: selected[0], label:validName})
		controller.renameNode(selected[0], willingToSelect = input1.value)
	}
	
	function flipButtonClicked() {
		var selected = network.getSelection().nodes
		var name1 = selected[0] ; var name2 = selected[1]
		//nodes.update({id: selected[0], label:validName})
		var temp = "flipping_temp 1bf4e67deadad20cc14d"
		controller.compound(function() {
			controller.renameNode(name1, temp)
			controller.renameNode(name2, name1)
			controller.renameNode(temp, name2)
		})
	}
	
	function visAdd(validName) {
		//add to graph
		var added = nodes.add({id: validName, label:validName})

		if (this.network) if (word_list.firstChild) {
			selected = network.nodes[word_list.firstChild.textContent] // nodes[id] fail for some reason*/
			var props = {x: selected.x, y: selected.y, allowedToMoveX: true, allowedToMoveY: true}
			network.nodes[validName].setProperties(props)
		}

		// add to list
		var li = document.createElement("LI");
		li.appendChild(document.createTextNode(validName));
		insertFirst(li)
	}
	
	function visConnect(nodeA, nodeB) {
		if (validEdgeDir(nodeA, nodeB)) 
			edges.add({id: edgeId(nodeA, nodeB), from: nodeA, to: nodeB})
		
		// this is needed due to bug 623, https://github.com/almende/vis/issues/623
		// Basically, edge edit unselects edges but it is reported as
		// selected in network.getSelection() and, thus, we enter 
		// edit edge mode instead of draw new edge on cotrol pres and crush
		//network.selectNodes([])
		
		// a better workaround. It unselects edges, leaving nodes selected
		if (this.network) network.selectNodes(network.getSelection().nodes)


	}

	function addnodeButtonClicked() {
		var connectTo = network.getSelection().nodes
		var newWords = input1.value.split(controller.separator)
		controller.compound(function() {
			for (var i in newWords) {
				var newWord = newWords[i].trim()
				if (controller.graph.get(newWord) == null)
					willingToSelect = controller.createNode(newWord)
				for (var key in connectTo)
					controller.connect(connectTo[key], newWord)
				connectTo.push(newWord) // chain new words together
			}
		})
		//input1.value = ""
	}
	function circleButtonClicked(plusAdded) {
		var ids = network.getSelection().nodes.concat(plusAdded)
		controller.compound(function() {
			for (var i = 1 ; i != ids.length ; i++)
				controller.connect(ids[i-1], ids[i])
			if (ids.length > 2) controller.connect(ids[ids.length-1], ids[0])
		})
	}
	
	function connButtonClicked(plusAdded) {
		var ids = network.getSelection().nodes.concat(plusAdded)
		controller.compound(function() {
			for (var i in ids) for (var j in ids)
				controller.connect(ids[i], ids[j])
		})
	}
	
	function mergeButtonClicked() {
		var ids = network.getSelection().nodes
		var survivor = ids[0] ; var victims = ids.slice().splice(1)
		controller.compound(function() {
			for (var v in victims) {
				var conns = controller.listConnections(victims[v])
				for (var c in conns) {
					if (ids.indexOf(conns[c]) == -1)
						controller.connect(survivor, conns[c])
				}
				controller.deleteNode(victims[v])
			}
		})
	}
	
	function breakNodesClicked() {
		var nodes = network.getSelection().nodes
		var victimEdges = []
		for (var i in nodes) for (var j in nodes) {
			var edge = edgeId(nodes[i], nodes[j])
			if (edges.get(edge) != null && validEdgeDir(nodes[i], nodes[j]))
				victimEdges.push(edge)
		}
		options.onDelete({edges:victimEdges}, function() {})
	}
	
	// can be called due to delete-cancel of when user confirmes the edit
	function recoverEditEdge() {
		ConnectMode_span.style.display = 'none'
		var newEdge = ConnectMode_span.editorData
		if (newEdge == null) return // no edit was actually started -- nothing to roll back
		edges.remove(newEdge.id)
		var originalConnection = newEdge.id.split(controller.separator)
		visConnect(originalConnection[0], originalConnection[1])
	}
	
	// called by controller.js
	function onMapValueChanged(evt) {
		if (evt.newValue == null) {
			//console.log("remote event: deleted " + evt.property)
			nodes.remove(evt.property)
			word_list.removeChild(getLI(evt.property))
			
		}
		else if (evt.oldValue == null) {
			//console.log("remote event: created " + evt.property)
			
			visAdd(evt.property)
			
			if (willingToSelect == evt.property) selectNode(willingToSelect)
			//circleButtonClicked([added])
		}
			
		else {
			console.log("remote event: model updated " +  evt.property + ": " + evt.oldValue + " => " + evt.newValue)
			var src = evt.property
			var listWas = evt.oldValue.split(controller.separator)
			var newList = evt.newValue.split(controller.separator)
			newList.map(function(n) {
				if (listWas.indexOf(n) == -1) {
					visConnect(src, n)
				}
			})
			listWas.map(function(w) {
				if (newList.indexOf(w) == -1) {
					edges.remove(edgeId(src, w))
				}
			});
		}
		
	}

	function validEdgeDir(a, b) { return a < b }
	
	function edgeId(a,b) {
		return (validEdgeDir(a,b) ? [a,b] : [b,a]).join(controller.separator)
	}
	
	function onFileLoaded() { 
		var keys = controller.graph.keys()
		//cy.startBatch() try {
		for (var i in keys) {
			var key = keys[i]
			visAdd(key)
			var associations = controller.listConnections(key)
			for (var j in associations)
				visConnect(key, associations[j])
		}
	  // create a network
		  //var container = document.getElementById('mynetwork');
		network = new vis.Network(
			network_div, {nodes: nodes, edges: edges}, options);
		network.editMode = true // https://github.com/almende/vis/issues/605#issue-55793606
		network._createManipulatorBar()
		network.on('select', onselect)
		network.keycharm.bind("esc", function(evt) {
			if (ConnectMode_span.style.display == 'block')
				recoverEditEdge()})

	}	
    </script>

</body>