<!--TODO: integration with model and hover show/hide
The must be a hover option to make object visible/hidden.
Hidden objects disappear when we recede the mouse too far away.
-->
  <script type="text/javascript" src="ValUtils.js"></script>
  <script type="text/javascript" src="controller.js"></script>

<div id="network_div" style=""></div>
<div id="controls">
  <a href="http://almende.github.io/vis/examples/network/21_data_manipulation.html">Almende</a>  <button onclick="alert(1)">You must authorize</button> <button>open file</button>
  <button onclick="deleteButtonClicked()">Delete Selected</button>
  <button id="rename_button" onclick="validateUserInput(renameButtonClicked)" disabled>Rename</button>
  <button onclick="validateUserInput(addnodeButtonClicked)">add node</button>
  <button id="connect_button" onclick="connectButtonClicked([])" disabled>connect</button>
  <input id="input1"/>
  <span id="ConnectMode_span" style="display:none">connect mode</span>
	</div>
	<style type="text/css">
	body {font-family:verdana}
	.network-manipulationLabel {display: none}
	#controls {
		left: 0; top: 0;
		position: absolute; 
		margin: 0;
		padding: 0;

	}
	#network_div {
		left: 0; top: 0;
		position: absolute;

		margin: 0;
		padding: 0;
		width: 100%;
		height: 100%;
	}
	</style>


  <!--
  <script src="http://almende.github.io/vis/dist/vis.js"></script>
  -->
  <script src="libs/vis.js"></script>
<script>
	//
	["keydown", "keyup"].map(function(evt) {
		window.addEventListener(evt, function(event) {
			// Bind to both command (for Mac) and control (for Win/Linux)
			if ((event.keyCode == 17)) {
				var down = event.type == 'keydown'
				var newDisplay = down ? 'block' : 'none'
				if (ConnectMode_span.style.display != newDisplay) {
					ConnectMode_span.style.display = newDisplay
					var element = down ? 'addEdgeSpan' : 'backSpan'
					if (network.manipulationDOM[element])
						network.manipulationDOM[element].onclick()
					else
						console.log('element ' + element + " undefined")
					//console.log(element + ' = ' + (func ? 'defined' : 'undefined') + ", constants = " + ValUtils.dictToStr(network.constants.locales)) 
					//var func = network[down ? '_createAddEdgeToolbar' : '_createManipulatorBar']
					//console.log(down + ' = ' + (func ? 'defined' : 'undefined') + ", constants = " + ValUtils.dictToStr(network.constants.locales)) 
				}
				
			}
		}, true);
	})
		

		var options = {
			onDelete: function(deleted, cb) {
				//todo: here we will only schedule node node delete
				// by removing them from the model. Model update
				// will call the real node delete (vis does not 
				// fire callbacks in this case). This will also 
				// remove empty edges because this is how we protect
				// our model.
				function delSelected(subset) {
					var selected = network.getSelection()[subset]
					for (var key in selected) {
						console.log('')
						this[subset].remove(selected[key]);
					}
				}
				delSelected('nodes')
				delSelected('edges')
				return cb(deleted)
			},
			dataManipulation: {enabled: true, initiallyVisible:false}
		};

		// create an array with nodes
		nodes = new vis.DataSet();
		nodes.subscribe('*', function (event, params, senderId) {
		//$('#nodes').html(toJSON(nodes.get()));
		});
		nodes.add([
			{id: '1', label: 'Node 1'},
			{id: '2', label: 'Node 2'},
			{id: '3', label: 'Node 3'},
			{id: '4', label: 'Node 4'},
			{id: '5', label: 'Node 5'}
		]);
		// create an array with edges
		edges = new vis.DataSet();
		edges.subscribe('*', function () {
		//$('#edges').html(toJSON(edges.get()));
		});
		edges.add([
			{id: '1', from: '1', to: '2'},
			{id: '11', from: '2', to: '1'},
			{id: '2', from: '1', to: '3'},
			{id: '3', from: '2', to: '4'},
			{id: '4', from: '2', to: '5'}
		]);
	  // create a network
		  //var container = document.getElementById('mynetwork');
		var network = new vis.Network(
			network_div, {nodes: nodes, edges: edges}, options);
		network.editMode = true // https://github.com/almende/vis/issues/605#issue-55793606
		network._createManipulatorBar()
		network.on('select', function(params) {
			console.log("params.nodes: " + params.nodes.join(',') + ", network.sel.nodes: " + network.getSelection().nodes.join(','))
			rename_button.disabled = (params.nodes.length != 1)
			connect_button.disabled = (params.nodes.length < 2)
		})

			//TODO: remove these functions once model is connected
			function validateName(name) {
				return name
			}
		
		function validateUserInput(nextOp) {
		var validated = validateName(input1.value.trim())
			return nextOp(validated)
		}

		function deleteButtonClicked() {
			// options.onDelete is called when user edits graph by del key.
			//It is not called when we manipulate nodes/edges programmatically.
			// We therefore call this callback directly.
			options.onDelete(network.getSelection() , function() {})
			
			//The problem is that some events will come from remote host
			// and we ought to break the loops so that remote event -> local graph delete  -> model.delete -> local graph delete -> ...
		}
		
		function renameButtonClicked(validName) {
			var selected = network.getSelection().nodes
			if (selected.length != 1) throw new Error("exactly one node must be selected. You have selected " + selected.length + ": " + ValUtils.dictToStr(selected))
			nodes.update({id: selected[0], label:validName})
		}
		
		function addnodeButtonClicked(validName) {
			var added = nodes.add({id: validName, label:validName})
			connectButtonClicked(added)
		}
		
		var edgeId = 100
		function connectButtonClicked(plusAdded) {
			var ids = network.getSelection().nodes.concat(plusAdded)
			console.log("joining = " + ids.join(','))
			//todo: edit model
			for (var i = 1 ; i != ids.length ; i++)
				edges.add({id: "e" + edgeId++, from: ids[i-1], to: ids[i]})
			if (ids.length > 2)
			edges.add({id: "e" + edgeId++, from: ids[ids.length-1], to: ids[0]})
			
		}
		
    </script>

  