<!--TODO: 
1. show/hide on hover. The must be a hover option to 
make object visible/hidden. Hidden objects disappear when we 
recede the mouse too far away.
2. List of words for search.


-->
<body onLoad="controller = new Controller()">
  <script type="text/javascript" src="https://apis.google.com/js/api.js"></script>
  <script type="text/javascript" src="realtime-client-utils.js"></script>
  <script type="text/javascript" src="controller.js"></script>

  <script src="libs/vis.js"></script>
  <!--
  <script src="http://almende.github.io/vis/dist/vis.js"></script>
  -->
<div id="network_div" style=""></div>

<div style="float: left; width:50; height: 100; font-size: xx-small"><ul id="word_list" class="controls"></ul><hr><span id="Summary"></span></div>




<table cellspacing="0" cellpadding="0" id="authorizeButton"> <tr> 
<td align="center" width="300" height="40" bgcolor="#000091" style="-webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; color: #ffffff; display: block;">
<a href="javascript:" style="font-size:16px; font-weight: bold; font-family: Helvetica, Arial, sans-serif; text-decoration: none; line-height:40px; width:100%; display:inline-block"><span style="color: #FFFFFF">You must authorize</span></a>
</td> 
</tr> </table> 
 

 
 
  <table onmouseenter="classVisible('aboutbar', 'block')" onmouseleave="classVisible('aboutbar', 'none')" style="float: right; font-size:small">
	  <tr id=resetButton style="display:none"><td><a href="javascript:nodes.clear(); edges.clear();" title="Clean up the display. You can achieve the same with F5-page refresh but this button is faster and unloads the server.">Reset</a>&nbsp;&nbsp;&nbsp;</td></tr>
	  <tr><td><a class="aboutbar" href="javascript:window.open('about.html' + location.hash)">About</a></td></tr>
	  <tr><td><a class="aboutbar" href="javascript:window.open('options.html' + location.hash)">Options</a></td></tr>
	  <tr><td><a class="aboutbar" href="http://almende.github.io/vis/examples/network/21_data_manipulation.html">Almende</a></td></tr>
	  <tr><td><button class="aboutbar" onclick="rtclient.selectOrCreateNew()">Anothr file</button></td></tr>
	  <tr><td><button class="aboutbar" onclick="GooglePick()">Ggl picker</button></td></tr>
  </table>
  <style>.aboutbar{display:none}</style>
  
  <!-- Undo and redo buttons. -->
  <table onmouseenter="redoButton.style.display = 'block'" onmouseleave="redoButton.style.display = 'none'" style="float: right">
	<tr><td><button id="undoButton" disabled>Undo</button></td></tr>
	<tr><td><button id="redoButton" style="display:none" disabled>Redo</button></td></tr>
  </table >
  
  <table onmouseenter="classVisible('connbar', 'block')" onmouseleave="classVisible('connbar', 'none')" style="float: right">
	<tr><td><button id="connect_button" onclick="connButtonClicked([])" disabled>strong Conn</button></td></tr>
	<tr><td><button class="connbar" id="circle_button" onclick="circleButtonClicked([])" disabled>circle Conn</button></td></tr>
	<tr><td><button class="connbar" id="breakNodes_button" onclick="breakNodesClicked()" disabled title="Breaks connections between selected nodes">break</button></td></tr>
	<tr><td><button class="connbar" id="delete_button" onclick="deleteButtonClicked()" disabled>Del Sel</button></td></tr>
	<tr><td><button class="connbar" id="flip_button" onclick="flipButtonClicked()" disabled>Flip Sel</button></td></tr>
  </table>
  <style>.connbar{display:none}</style>
  <table onmouseenter="classVisible('addbar', 'block')" onmouseleave="classVisible('addbar', 'none')" style="float: right">
	<tr><td><input id="input1" onkeydown="if (event.keyCode == 13) addnodeButtonClicked()"/></td></tr>
	<tr><td><button class="addbar" id="add_button" onclick="addnodeButtonClicked()" style="display:none">add node</button></td></tr>
	<tr><td><button class="addbar1" id="rename_button" onclick="renameButtonClicked()" style="display:none">Rename</button></td></tr>
  </table>

	<script>
		function classVisible(cls, visibility) {
			var controls = document.querySelectorAll("." + cls);
			for (var k=0 ; k < controls.length; k++)
				controls[k].style.display = visibility

		}
		
		word_list.addEventListener("click", function(e) {
			if(e.target && e.target.nodeName == "LI") {
				//console.log(e.target.textContent + " was clicked");
				selectNode(e.target.textContent)
				network.focusOnNode(e.target.textContent, {
					scale: 1, offset: {x:0,y:0},
						animation: {
							duration: 2500,
							easingFunction: 'easeInOutQuad'
						}
				})
				window.scrollTo(0,0) // browser jump. Useful for long lists
			}
		});
		
		function selectNode(id) {
			var selected = (shiftPressed) ? network.getSelection().nodes : []
			selected.push(id) ; console.log("select node " + id + " caused partial expand"); partialExpand(id, 1, topLocation())
			network.selectNodes(selected) // select in graph
			onselect(network.getSelection())
		}
		
		function getLI(word) {
			var list = word_list.querySelectorAll('li');
			for (var k in list)
				if (list[k].textContent == word) 
					return list[k]
		}
		
		/* 
		// highlight selected words in list
		var listSelected = []
		function updateListSelection(justSelected) {
			for (var k in listSelected) {
				listSelected[k].style['font-size'] = "xx-small"
				listSelected[k].style['font-weight'] = "normal"
			}
			listSelected = []
			
			for (k in justSelected) {
				var li = getLI(justSelected[k]) 
				li.style['font-size'] = "large"
				li.style['font-weight'] = "bold"
				listSelected.push(li)
			}
		}*/
		function insertFirst(li) {
			if (word_list.firstChild) word_list.insertBefore(li, word_list.firstChild);
			else word_list.appendChild(li);
		}
		function updateListSelection(justSelected) {
			for (k in justSelected) {
				var li = getLI(justSelected[k])
				word_list.removeChild(li)
				insertFirst(li)
			}
		}

	</script>
  
  
  <span id="ConnectMode_span" style="display:none; z-index:-1000">connect mode</span>
	<style type="text/css">
	body {font-family:verdana}
	.network-manipulationLabel {display: none}
	a, span, table, button, input, .controls { position: relative; left: 0; top: 0; margin: 0; padding: 0;}
	#network_div { position: absolute; left: 0; top: 0; margin: 0; padding: 0; width: 100%; height: 100%; }
	</style>


<script>

	var errorsOccured = false
	window.onerror = function(errorMsg, url, lineNumber, colNo, e) {
		if (!errorsOccured)
			alert("Error " + errorMsg + " in " + url + ", line " + lineNumber + ". Watch the developer console.");
		errorsOccured = true
	};
	
	var shiftPressed = undefined ; 
	
	["keydown", "keyup"].map(function(evt) {
		window.addEventListener(evt, function(event) {
			// Bind to both command (for Mac) and control (for Win/Linux)
			shiftPressed = event.shiftKey
			if (event.keyCode == 17) {
				var down = event.type == 'keydown'
				var newDisplay = down ? 'block' : 'none'
				if (ConnectMode_span.style.display != newDisplay) {

					ConnectMode_span.style.display = newDisplay
					
					if ((network.getSelection().edges.length == 1)) {
						console.log('edit mode ' + network.getSelection().edges[0])
						//edit edge mode
						if (down) {
							ConnectMode_span.editorData = null
							network._createEditEdgeToolbar.call(network)
						}
						else {
							network._createManipulatorBar.call(network)
							recoverEditEdge()
							var newEdge = ConnectMode_span.editorData
							if (newEdge != null) {
								controller.compound(function() {
									controller.removeEdge(newEdge.id)
									controller.connect(newEdge.from, newEdge.to)
								})
							}
						}


					} else {
						// new connection mode
						console.log('new conn mode')
						network[down ? '_createAddEdgeToolbar' : '_createManipulatorBar']
							.call(network)
						/*if (network.manipulationDOM[element])
							network.manipulationDOM[element].onclick()
						else
							console.log('element ' + element + " undefined")*/
					}

				}
				
			} else if (ConnectMode_span.style.display != 'none') {
				//console.log('another key pressed!') // need to stop conn mode immediately (it has side effects)
				network._createManipulatorBar.call(network)
				ConnectMode_span.style.display = 'none'
			}
		}, true);
	})
	

	var options = {
		dataManipulation: {enabled: true, initiallyVisible:false},
		onConnect: function (edge, callback) {
			console.log('on connect ' + str(edge, true))
			controller.connect(edge.from, edge.to)
			callback([]); // cancel update. Do it with model update
		},
		onEditEdge: function (edge, callback) {
			callback(ConnectMode_span.editorData = edge); // track changes
		},
		/*nodes: { // having only text obfuscates its location on the edges
			shape: "text",
			color: {
				border: 'orange',
				background: 'white',
			}
		}*/
	};

	function control(func) {
		controller[func](input1.value)
	}
	
	function deleteButtonClicked() {
		// fired when user (rather than graph) initiates removal
		// Do the same as when graph initiates removal
		options.onDelete(network.getSelection() , function() {})
	}
	
	//fired when graph (rather than user) initiates removal. 
	// Promote the command to the model. Actualy graph will be
	// pruned on model update event.
	options.onDelete = function(deleted, cb) {
		controller.compound(function() {
			for (var key in deleted.edges) {
				console.log('deleting ' + deleted.edges[key])
				controller.removeEdge(deleted.edges[key])
			}
			for (var key in deleted.nodes) {
				console.log('deleting ' + deleted.nodes[key])
				controller.deleteNode(deleted.nodes[key])
			}
			return cb([]) // cancel delete -- do in on model update
		})
	}

	// create an array with nodes
	nodes = new vis.DataSet();
	edges = new vis.DataSet();

	function onselect(selected) {
		var nodes = selected.nodes
		console.log("selected.nodes: " + nodes.join(',') + ", network.sel.nodes: " + network.getSelection().nodes.join(','))
		delete_button.disabled = nodes.length + selected.edges.length == 0
		connect_button.disabled = circle_button.disabled =
		breakNodes_button.disabled = (nodes.length < 2)

		rename_button.className = (nodes.length == 0) ? 'addbar1' : 'addbar' 
		rename_button.innerHTML = (nodes.length < 2) ? 'Rename' : "Merge"
		flip_button.disabled = (nodes.length != 2)
		
		// select item in the list
		updateListSelection(nodes)
	}
	
	function flipButtonClicked() {
		var selected = network.getSelection().nodes
		var name1 = selected[0] ; var name2 = selected[1]
		//nodes.update({id: selected[0], label:validName})
		var temp = "flipping_temp 1bf4e67deadad20cc14d"
		controller.compound(function() {
			controller.renameNode(name1, temp)
			controller.renameNode(name2, name1)
			controller.renameNode(temp, name2)
		})
	}
	
	function enlistTheWord(word) {
		var li = document.createElement("LI");
		li.appendChild(document.createTextNode(word));
		insertFirst(li)
	}

	function expandFirst() {
			var fi = word_list.firstChild ; if (fi) {
				partialExpand(fi.textContent, 1, {x:0, y:0})
				fi.click()
			}
	}
	
	function topLocation() {
		if  (!word_list.firstChild) return {x:0, y:0}
		var firstNode = network.nodes[word_list.firstChild.textContent]
		return firstNode == null ? {x:0, y:0} : firstNode
	}
	
	function str(obj, displayValues) { // debug function
			if (!obj) return undefined
			var result = Object.keys(obj)
			if (displayValues) result = result.map(function(item) {return item + " => " + obj[item]})
			return result.join(',')
	}
	
	function makeProxy(id, location) {
		if (nodes.get(id) == null) {
			nodes.add({id: id, label: id, x: location.x, y: location.y, allowedToMoveX: true, allowedToMoveY: true, shape: 'dot', title:id})
		}
	}

	function foreach(node, f) {
		var links = controller.listConnections(node)
		for (var l in links) f(links[l])
	}
			
	/*depth == 0: stop descending and pop up a proxy for any unavailable connection */
	function partialExpand(id, depth, location) {
	
		function log(msg) {
			console.log(new Array(depth ).join(" ") + msg)
		}

		// Nodes.get(id) returns the object added by nodes.add(node) whereas network.nodes[id] is related 
		// graph node. It has no 'shape' or 'title' but contains right current coordinages.
		var existent = nodes.get(id) ;
		if (existent != null && existent.shape == "dot") { location = network.nodes[id] ; 
			nodes.remove(id); existent = null}
		
		if (existent == null) {
			function join(buddy) {
				if (network.edges[edgeId(id, buddy)] == null) {
					visConnect(buddy, id, location) ; visConnect(id, buddy, location)
				}
			}
			if (depth == 0) {
				makeProxy(id, location)
				foreach(id, function (buddy) {var node = nodes.get(buddy); if (node != null) join(buddy)})
			} else  { 
			
				nodes.add({id: id, label:id, x: location.x, y: location.y, allowedToMoveX: true, allowedToMoveY: true})

				foreach(id, function (buddy) { partialExpand(buddy, depth-1, network.nodes[id]) ; join(buddy)})
				
			}
		}

		//updateListSelection([id]) // not effective because all expanded will move to the front of list
	}
	
	function visConnect(nodeA, nodeB, location) {
		if (validEdgeDir(nodeA, nodeB)) {
			if (location) ; else location = topLocation()
			makeProxy(nodeA, location) ; makeProxy(nodeB, location)
			edges.add({id: edgeId(nodeA, nodeB), from: nodeA, to: nodeB})
		}
		
		// this is needed due to bug 623, https://github.com/almende/vis/issues/623
		// Basically, edge edit unselects edges but it is reported as
		// selected in network.getSelection() and, thus, we enter 
		// edit edge mode instead of draw new edge on cotrol pres and crush
		//network.selectNodes([])
		
		// a better workaround. It unselects edges, leaving nodes selected
		if (this.network) network.selectNodes(network.getSelection().nodes)


	}

	function addnodeButtonClicked() {
		var connectTo = network.getSelection().nodes
		var newWords = input1.value.split(controller.separator).map(function(word) {return word.trim()})
		controller.compound(function() {
			for (var i in newWords) {
				var newWord = newWords[i].trim()
				if (controller.graph.get(newWord) == null)
					willingToSelect = controller.createNode(newWord)
				for (var key in connectTo)
					controller.connect(connectTo[key], newWord)
				connectTo.push(newWord) // chain new words together
			}
		})
		//input1.value = ""
	}
	function circleButtonClicked(plusAdded) {
		var ids = network.getSelection().nodes.concat(plusAdded)
		controller.compound(function() {
			for (var i = 1 ; i != ids.length ; i++)
				controller.connect(ids[i-1], ids[i])
			if (ids.length > 2) controller.connect(ids[ids.length-1], ids[0])
		})
	}
	
	function connButtonClicked(plusAdded) {
		var ids = network.getSelection().nodes.concat(plusAdded)
		controller.compound(function() {
			for (var i in ids) for (var j in ids)
				controller.connect(ids[i], ids[j])
		})
	}
	
	function renameButtonClicked() {

		//controller.renameNode(selected[0], willingToSelect = input1.value)

		var victims = network.getSelection().nodes
		var target = willingToSelect = input1.value.trim()
		controller.compound(function() {
			if (victims.indexOf(target) != -1) victims = victims.filter(function(v) {return v != target}) // if target exists among selected -- merge to it
			else if(nodes.get(target) != null) {} // merge to another existing node
			else controller.createNode(target) // if target existent -- create
			console.log("replacing " + victims.join(",") + " with " + target)
			for (var v in victims) {
				foreach(victims[v], function(buddy) {if (victims.indexOf(buddy) == -1) controller.connect(target, buddy)})
				controller.deleteNode(victims[v])
			}
		})
		onselect(network.getSelection())
	}
	
	function breakNodesClicked() {
		var nodes = network.getSelection().nodes
		var victimEdges = []
		for (var i in nodes) for (var j in nodes) {
			var edge = edgeId(nodes[i], nodes[j])
			if (edges.get(edge) != null && validEdgeDir(nodes[i], nodes[j]))
				victimEdges.push(edge)
		}
		options.onDelete({edges:victimEdges}, function() {})
	}
	
	// can be called due to delete-cancel of when user confirmes the edit
	// can be called due to delete-cancel of when user confirmes the edit
	// NewEdge.id has wrong from/to after edit. Remove and
	// recreate it.
	function recoverEditEdge() {
		ConnectMode_span.style.display = 'none'
		var newEdge = ConnectMode_span.editorData
		if (newEdge == null) return // no edit was actually started -- nothing to roll back
		edges.remove(newEdge.id)
		var originalConnection = newEdge.id.split(controller.separator)
		visConnect(originalConnection[0], originalConnection[1])
	}
	
	// called by controller.js
	function onMapValueChanged(evt) {
		if (evt.newValue == null) {
			Summary.update(-1) ; console.log("remote event: deleted " + evt.property)
			nodes.remove(evt.property)
			word_list.removeChild(getLI(evt.property))
			if (nodes.length == 0) expandFirst()
			
		}
		else if (evt.oldValue == null) {
			Summary.update(+1) ; console.log("remote event: created " + evt.property)

			var selected = topLocation()
			nodes.add({id: evt.property, label:evt.property, x: selected.x, y: selected.y, allowedToMoveX: true, allowedToMoveY: true})
			
			enlistTheWord(evt.property)
			if (willingToSelect == evt.property) selectNode(willingToSelect)
		}
			
		else {
			console.log("remote event: model updated " +  evt.property + ": " + evt.oldValue + " => " + evt.newValue)
			var src = evt.property
			var listWas = evt.oldValue.split(controller.separator)
			var newList = evt.newValue.split(controller.separator)
			newList.map(function(n) {
				if (listWas.indexOf(n) == -1)
					visConnect(src, n)
				
			})
			listWas.map(function(w) {
				if (newList.indexOf(w) == -1) {
					edges.remove(edgeId(src, w))
				}
			});
		}
		
	}

	function validEdgeDir(a, b) { return a < b }
	
	function edgeId(a,b) {
		return (validEdgeDir(a,b) ? [a,b] : [b,a]).join(controller.separator)
	}
	
	function isPartial() {return controller.getConfiguration().get('almende-mode') == 'partial'}
	
	function onFileLoaded() {

		if (location.search.indexOf("mode=") != -1)
			controller.setConfig('almende-mode', location.search.replace("?mode=", ""))
		
		options.clustering = controller.getConfiguration().get('almende-mode') == 'cluster'
		
		var knots = controller.graph.keys()
		for (var k in knots) enlistTheWord(knots[k])
		Summary.update=function(delta) {this.value += delta ; this.innerHTML = this.value + " words"}
		Summary.value=0 ; Summary.update(knots.length)

		if (!isPartial()) for (var i in knots) { //cy.startBatch() try {
			var node = knots[i]
			var added = nodes.add({id: node, label:node})
			var associations = controller.listConnections(node) ; for (var j in associations)  visConnect(node, associations[j])
		} else
			resetButton.style.display = 'block'


		network = new vis.Network(network_div, {nodes: nodes, edges: edges}, options);
		network.editMode = true // https://github.com/almende/vis/issues/605#issue-55793606
		network._createManipulatorBar()
		network.on('select', onselect)
		network.keycharm.bind("esc", function(evt) {
			if (ConnectMode_span.style.display == 'block') recoverEditEdge()})

		// make distance eucledian https://github.com/almende/vis/issues/729
		network._nodeInActiveArea = function(node) {
			function squared(x) { return Math.pow(node[x] - network.areaCenter[x],2)}
			return Math.pow(squared('x') + squared('y'), 1/2) < this.constants.clustering.activeAreaBoxSize/2/this.scale
		}
	}	
    </script>

</body>